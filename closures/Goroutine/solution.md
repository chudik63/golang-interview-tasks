# Solution
## < 1.22

Во-первых, скорее всего ничего. Чтобы это решить необходимо добавить `WaitGroup`, т.к цикл и `main` завершатся быстрее, чем запуститься первая горутина
```go
package main

import "fmt"

func main() {
	wg := &sync.WaitGroup{}

	for i := 0; i < 5; i++ {
		wg.Add(1)

		go func() {
			fmt.Println(i)
			wg.Done()
		} ()
	}

	wg.Wait()
}
```

Во-вторых, в зависимости от того, в каком порядке начнут выполняться горутины, вывод может отличаться, но факт, что все цифры по порядку мы не увидим. Ответом может быть, как и 
```
5
5
5
5
5
```
так и, например:
```
5
5
5
3
3
```
Какие-то горутины, которые были вызваны на итерации `i = 3`, успели запуститься раньше и захватить переменную в середине цикла.

Проблема в том, что в версиях го до 1.22 подобные вызовы внутри цикла захватывали переменную по указателю. Соответственно горутины, запустившиеся после цикла, ссылались на `i`, которая в конце всего была равна `5`.

Как решить?

1) Передать переменную в аргументы фнукции
```go
package main

import "fmt"

func main() {
	wg := &sync.WaitGroup{}

	for i := 0; i < 5; i++ {
		wg.Add(1)

		go func(i int) {
			fmt.Println(i)
			wg.Done()
		} (i)
	}

	wg.Wait()
}
```

2) Т.н shadowing
```go
package main

import "fmt"

func main() {
	wg := &sync.WaitGroup{}

	for i := 0; i < 5; i++ {
		wg.Add(1)

		i := i

		go func() {
			fmt.Println(i)
			wg.Done()
		} ()
	}

	wg.Wait()
}
```

## > 1.22
Мы увидим все цифры в указанном диапазоне. Однако, гарантировать порядок их вывода нельзя, так как все зависит от планировщика:
```
4
1
0
3
2
```